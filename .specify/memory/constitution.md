<!--
Sync Impact Report:
===================
Version Change: 1.0.0 → 1.1.0 (MINOR bump)
Modified Principles:
  - Принцип IV: UI библиотека Ant Design → shadcn/ui + Tailwind CSS
  - Технологический Стек: обновлена UI библиотека
Modified Sections:
  - Принцип IV полностью переписан для shadcn/ui + Tailwind CSS
  - Добавлены правила mobile-first подхода
  - Добавлены правила размещения компонентов в shared/ui/shadcn/
  - Обновлена секция обоснования с новыми преимуществами
Reason: Фича 001-mobile-first-ui-redesign требует полной миграции от Ant Design к shadcn/ui для обеспечения mobile-first UX и современного дизайна
Templates Status:
  ✅ plan-template.md - совместима (Constitution Check секция работает)
  ✅ spec-template.md - совместима (требования и структура поддерживаются)
  ✅ tasks-template.md - совместима (FSD структура сохранена)
Follow-up TODOs:
  - Обновить CLAUDE.md в корне проекта (Active Technologies)
  - При будущих фичах использовать shadcn/ui вместо Ant Design
-->

# Free Diet Constitution

## Основные Принципы

### I. TypeScript без Any

**Декларация**: Весь код проекта ДОЛЖЕН быть написан на TypeScript с строгим запретом использования типа `any`.

**Правила**:

- Использование `any` запрещено во всех файлах проекта
- Все переменные, параметры функций и возвращаемые значения ДОЛЖНЫ иметь явную типизацию
- Для сложных типов использовать utility types TypeScript (`Partial`, `Pick`, `Omit`, и т.д.)
- Для неизвестных типов использовать `unknown` вместо `any` с последующей проверкой типов
- В конфигурации TypeScript ДОЛЖНЫ быть включены строгие опции:
  - `strict: true`
  - `noImplicitAny: true`
  - `strictNullChecks: true`

**Обоснование**: Строгая типизация предотвращает ошибки на этапе компиляции, улучшает читаемость кода, обеспечивает лучшую поддержку IDE и делает рефакторинг безопасным.

### II. Feature-Sliced Design (FSD)

**Декларация**: Архитектура проекта ДОЛЖНА соответствовать методологии Feature-Sliced Design.

**Правила**:

- Структура проекта организована по слоям:
  - `app/` - инициализация приложения, провайдеры, роутинг
  - `pages/` - страницы приложения, композиция виджетов
  - `widgets/` - самостоятельные блоки страниц
  - `features/` - действия пользователя, бизнес-логика
  - `entities/` - бизнес-сущности проекта
  - `shared/` - переиспользуемые компоненты, утилиты, UI-kit
- Каждый слой может импортировать только нижележащие слои
- Внутри каждого слайса используется структура:
  - `ui/` - React компоненты
  - `model/` - бизнес-логика, хранилище (Zustand)
  - `api/` - запросы к API (Axios)
  - `lib/` - вспомогательные функции
  - `index.ts` - публичный API слайса
- Запрещены кросс-импорты между слайсами одного уровня

**Обоснование**: FSD обеспечивает предсказуемую структуру проекта, упрощает масштабирование, улучшает поддерживаемость и позволяет командам работать параллельно над разными фичами.

### III. Форматирование и Линтинг

**Декларация**: Проект ДОЛЖЕН использовать Prettier для форматирования и ESLint для статического анализа кода.

**Правила**:

- Prettier настроен для автоматического форматирования всех TypeScript/TSX файлов
- ESLint настроен с рекомендуемыми правилами для TypeScript и React
- Запуск проверки линтера обязателен перед каждым коммитом (через husky pre-commit hook)
- Все предупреждения ESLint ДОЛЖНЫ быть исправлены перед мержем в основную ветку
- Конфигурация Prettier и ESLint ДОЛЖНА быть единой для всей команды
- Плагины ESLint:
  - `@typescript-eslint` - правила для TypeScript
  - `eslint-plugin-react` - правила для React
  - `eslint-plugin-react-hooks` - правила для React Hooks
  - `eslint-config-prettier` - отключение конфликтующих правил

**Обоснование**: Единый стиль кода улучшает читаемость, уменьшает количество споров о форматировании в code review, предотвращает типичные ошибки и обеспечивает консистентность кодовой базы.

### IV. UI библиотека shadcn/ui + Tailwind CSS

**Декларация**: Для UI компонентов ДОЛЖНА использоваться библиотека shadcn/ui с Tailwind CSS.

**Правила**:

- Все стандартные UI компоненты (кнопки, формы, таблицы, модалы, диалоги) ДОЛЖНЫ использовать компоненты из shadcn/ui
- Кастомные компоненты создаются через композицию shadcn/ui primitives (на основе Radix UI)
- Стилизация выполняется через:
  - Tailwind CSS utility classes для всех стилей
  - Design tokens систему в `shared/config/` для цветов, spacing, typography
  - CSS variables для темизации (светлая/темная темы)
- shadcn/ui компоненты размещаются в `shared/ui/shadcn/` согласно FSD архитектуре
- Mobile-first подход обязателен: все компоненты сначала оптимизируются для мобильных устройств, затем адаптируются для desktop
- Запрещено использование inline styles, все стили через Tailwind classes

**Обоснование**: shadcn/ui headless компоненты обеспечивают полную кастомизацию и доступность, Tailwind CSS идеален для mobile-first подхода и адаптивного дизайна, меньший bundle size по сравнению с тяжелыми UI библиотеками, лучшая производительность на мобильных устройствах, современный визуальный стиль соответствующий трендам 2025 года.

### V. Управление Состоянием через Zustand

**Декларация**: Глобальное состояние приложения ДОЛЖНО управляться через библиотеку Zustand.

**Правила**:

- Каждый store размещается в соответствующем слайсе в папке `model/`
- Store ДОЛЖЕН быть типизирован с использованием TypeScript интерфейсов
- Использовать принцип единственной ответственности: один store на одну бизнес-область
- Для асинхронных операций создавать отдельные actions в store
- Локальное состояние компонентов управляется через `useState`, глобальное - через Zustand
- Структура store:

  ```typescript
  interface StoreState {
    // данные
  }

  interface StoreActions {
    // действия
  }

  type Store = StoreState & StoreActions;
  ```

- Селекторы используются для оптимизации ре-рендеров

**Обоснование**: Zustand предоставляет простой и минималистичный API, не требует boilerplate кода, имеет отличную TypeScript поддержку и хорошую производительность.

### VI. HTTP Клиент Axios

**Декларация**: Все HTTP запросы ДОЛЖНЫ выполняться через библиотеку Axios.

**Правила**:

- Axios инстанс конфигурируется в `shared/api/` с базовыми настройками:
  - Base URL
  - Timeout
  - Interceptors для обработки ошибок
  - Interceptors для добавления токенов авторизации
- API методы размещаются в `api/` папках соответствующих слайсов
- Все запросы ДОЛЖНЫ быть типизированы (request и response типы)
- Обработка ошибок выполняется централизованно через interceptors
- Используется структура:

  ```typescript
  // shared/api/client.ts
  export const apiClient = axios.create({ ... });

  // entities/user/api/userApi.ts
  export const userApi = {
    getUser: (id: string): Promise<User> => { ... }
  };
  ```

**Обоснование**: Axios предоставляет удобный API для работы с HTTP, поддерживает interceptors для централизованной обработки ошибок и трансформации данных, имеет встроенную защиту от XSRF и работает как в браузере, так и в Node.js.

### VII. Политика Тестирования

**Декларация**: В текущей фазе проекта автоматизированное тестирование НЕ является обязательным требованием.

**Правила**:

- Написание unit, integration и e2e тестов является опциональным
- Если тесты добавляются, они ДОЛЖНЫ:
  - Быть размещены рядом с тестируемым кодом в папке `__tests__/`
  - Использовать единый фреймворк (рекомендуется Vitest или Jest)
  - Быть полностью типизированными
- Ручное тестирование функциональности обязательно перед мержем в основную ветку
- Quality assurance обеспечивается через:
  - TypeScript строгую типизацию
  - ESLint статический анализ
  - Code review
  - Ручное тестирование

**Обоснование**: На ранних стадиях проекта или для небольших команд overhead от написания тестов может замедлить скорость разработки. TypeScript и ESLint обеспечивают базовый уровень качества кода без дополнительных затрат времени на тесты.

## Технологический Стек

### Frontend

- **Язык**: TypeScript (strict mode)
- **UI Framework**: React
- **UI библиотека**: shadcn/ui + Tailwind CSS
- **Управление состоянием**: Zustand
- **HTTP клиент**: Axios
- **Сборщик**: Vite (рекомендуется) или Webpack
- **Линтер**: ESLint с TypeScript плагинами
- **Форматтер**: Prettier

### Инструменты разработки

- **Package Manager**: npm, yarn или pnpm
- **Git Hooks**: husky для pre-commit проверок
- **IDE**: VS Code (рекомендуется) с расширениями:
  - ESLint
  - Prettier
  - TypeScript and JavaScript Language Features

## Структура Проекта

```
src/
├── app/                    # Инициализация приложения
│   ├── providers/          # Провайдеры (Router, Theme и т.д.)
│   ├── styles/             # Глобальные стили
│   └── index.tsx           # Точка входа
├── pages/                  # Страницы приложения
│   └── [page-name]/
│       ├── ui/
│       └── index.ts
├── widgets/                # Виджеты (композиция features)
│   └── [widget-name]/
│       ├── ui/
│       └── index.ts
├── features/               # Фичи (действия пользователя)
│   └── [feature-name]/
│       ├── ui/
│       ├── model/
│       ├── api/
│       └── index.ts
├── entities/               # Бизнес-сущности
│   └── [entity-name]/
│       ├── ui/
│       ├── model/
│       ├── api/
│       └── index.ts
└── shared/                 # Переиспользуемые ресурсы
    ├── ui/                 # UI-kit компоненты
    ├── api/                # API клиент, базовые запросы
    ├── lib/                # Утилиты, хелперы
    ├── config/             # Конфигурация приложения
    └── types/              # Общие типы
```

## Процесс Разработки

### Code Review

- Все изменения ДОЛЖНЫ проходить code review перед мержем
- Reviewer проверяет:
  - Соответствие FSD архитектуре
  - Отсутствие `any` типов
  - Правильность типизации
  - Использование Ant Design компонентов
  - Соблюдение стандартов форматирования
  - Корректность работы с Zustand stores
  - Правильность обработки Axios запросов

### Git Workflow

- Используется feature branch workflow
- Названия веток: `feature/`, `fix/`, `refactor/`
- Коммиты следуют Conventional Commits:
  - `feat:` - новая функциональность
  - `fix:` - исправление бага
  - `refactor:` - рефакторинг без изменения функциональности
  - `style:` - форматирование, отступы
  - `docs:` - документация

### Pre-commit Проверки

- ESLint проверка всех измененных файлов
- Prettier форматирование
- TypeScript компиляция без ошибок

## Управление

### Изменения Конституции

- Изменения в конституции требуют обсуждения с командой
- Мажорные изменения (удаление/изменение принципов) требуют консенсуса
- Минорные изменения (добавление принципов) требуют одобрения тимлида
- Патч изменения (уточнения, опечатки) могут вноситься любым разработчиком

### Версионирование

- MAJOR: Удаление или несовместимое изменение принципов
- MINOR: Добавление новых принципов или секций
- PATCH: Уточнения, исправления, улучшение формулировок

### Compliance Review

- Регулярная проверка соответствия кода конституции
- Выявление технического долга при нарушении принципов
- Планирование рефакторинга для приведения кода в соответствие

**Version**: 1.1.0 | **Ratified**: 2025-11-03 | **Last Amended**: 2025-11-04
